HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;

HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据因为在查询上使用散列码（通过键生成一个数字作为数组下标，这个数字就是hash code）所以在查询上的访问速度比较快，HashMap最多允许一对键值对的Key为Null，允许多对键值对的value为Null。它是非线程安全的。在排序上面是无序的。

默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。

具体的put过程

1.对key’值进行求hash值，然后再计算下标。

2.如果没有碰撞，直接放入桶中（空桶），（碰撞的意思就是计算出来的hash值相同，需要放在同一个桶中）。

3.如果碰撞了，用equals方法比较key值内容是否相同，相同就替代值，不同就链接到链表后面。

4.如果链表长度超过阀值8，就把链表转成红黑树，链表长度低于6，就不红黑树 ,转换为链表。

5.如果所有的桶满了（容量16*加载因子0.75），就需要resize（扩容2倍后重排）

之所以选择红黑树，是因为二叉树在特定情况下，会形成一条线的结构，这跟链表查询的一样了，造成查询很深的问题，遍历查询会变的非常的慢，二红黑树就是为了查询速度快，解决链表查询深度的问题，我们知道红黑树是属于平衡二叉树，但是为了保持平衡是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表的长度很短 的话，使用红黑树，反而会更慢


当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了

如果两个键的hashcode相同，你如何获取值对象？”当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，HashMap在链表中存储的是键值对，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。

ConcurrentHashMap为什么高效？
　　Hashtable低效主要是因为所有访问Hashtable的线程都争夺一把锁。如果容器有很多把锁，每一把锁控制容器中的一部分数据，那么当多个线程访问容器里的不同部分的数据时，线程之前就
不会存在锁的竞争，这样就可以有效的提高并发的访问效率。
　　这也正是ConcurrentHashMap使用的分段锁技术。将ConcurrentHashMap容器的数据分段存储，每一段数据分配一个Segment（锁），当线程占用其中一个Segment时，其他线程可正常访问
其他段数据。